INFO:
* Drawing the last trace line segment and the arrow separate is impossible, since in cases where the line segments are very short, even previous segments are visible beyond the tip af the arrow

TODO:
* Check, if it makes sense to use canvas-functions as xview(), xview_scroll(), canvasx() and it's y-counterparts - probalby they are only interesting, if all items stay on the canvas and not when deleting all items in each cycle.
* Check, if it is feasible to keep track of all elements created (drawn) on the canvas and update them instead of deleting all and creating them anew.
* Unify all function and variable names and also structure them more, e.g. pack them in classes if useful.
* scalable_canvas.py: Try to unify the two functions that scale coordinates (for creating drawing elements and for the scaled motion event) - attention: the order of multiplication and addition is changed and the mathematical inverse operator is used except for the invert_y.
* scalable_canvas.py: Instead of get_* and set_* use real getters and setters or remove the existing ones, if they are not really needed - also adapt function to return tuples for x and y instead of separate functions.
* Put more comments in the code.
* On the ScalableCanvas <Configure> event the objects can even move out of the window then changing the window size - this seems only to happen when the object got moved away from the origin before.
* How to handle the scale factors (10000., etc.) in vehicle_visu, especially when changing the velocity and acceleration or when adding further vehicles with different parameters.
* Test, if by choosing the element nearest to the mouse pointer on the canvas and keeping track of the association of the line segment, etc. to the vehicle/sensor, it is possible to select e.g. a sensor and interaxt with it (e.g. show a list of the recent measurements)
* Check, if complex numbers or a self defined type or tuples might make things easier with the (x, y) pairs. See http://effbot.org/zone/tkinter-complex-canvas.htm.
* Get the simulator run in a conda environment and document the steps to do so.
* Don't set fixed initial values for dynamic labels, but try to use invoke() instead.
* Add further settings for vehicles and/or sensors in a context menu or separate window when clicking on the sensor box.
* Make a combobox list widget derived from the ScrollFrame and use it for the vehicle and sensor list.
* Add all exercises from the 4th lecture.
* Check, if it makes sense to make a separate class that connects the vehicles ans sensor/measurements and connect them directly at the program startup (or when adding a vehicle or sensor).
+ Make the state vector of 6 instead of 2 dimensions
* Add multiple sensors in different locations and join their measurements with their arithmetic and their geometric average.
* Create a function, that rotates (in dependence of the angle between the sensor and the vehicle) a covariance matrix und rotate the base covariance matrices on each measurement once and store the result in a new variable and use this variable for all further steps:
  * Sampling points
  * Draw covariance ellipse
  * Calculate Q of the Kalman filter
* Introduce a sensor group class which contains one or more sensors.
  * The sensor group acts as a trigger for all contained sensors.
  * The sensors itself will loose their measurement interval property, since this will be moves to the sensor group.
  * The sensor group will trigger the measurements and handle the results of the individual sensors as a single one, according to the selected mode (arithmetic or geometric mean).
  * Check, if it makes sense, to allow a sensor to be added to multiple groups.
* Strictly separate logic and gui - use callback/hooks?
* Are R1 and R2 really HomogeniousTriggeredSensorGroup? What if we have a group of inhomogeneous sensors, how to set the covariance matrix for each sensor, since it got removed? Try to unify this.
* Explicitly add a vehicle to a sensor, instead of waiting until it get's measured the first time? Which one is better?
* Implement exercises 4* and 5*.
* Fix syntax warning on the derived functions from Sensor.measure().
* The arrow of the trace with the Kalman filtered measurements is most of the time not visible - fix it! Should be somewhere in BaseVisu.
* Finish implementing Radar.measure and in general the whole Radar class.
* Treat the sensor measurement and the Kalman filter result in a separate class suitable for the used sensor. In general put all code related to a sensor type in the class where the sensor is defined.
* Adapt the SensorVisu ans SensorGroupVisu to the new interfaces in a way that allows to handle stand alone sensors the same way as sensor groups.
