* vehicle_visu.py: Don't use only a single vehicle, but use a list instead, allow to add more vehicles and iterate through all vehicles.
* gui.py: Check, if it would make sense to use a Grid for placing the GUI elements.
* gui.py: Add switch to allow plotting over time instead of 2D - but how to separate the components x and y? Make two graphs for each 2D graph?
* gui.py: Add slider for speed and for step width (t increment) and show the current values on a label.
* gui.py: Add to the reset button probably even more values os the time increment e.g.
* Check, if it makes sense to use canvas-functions as xview(), xview_scroll(), canvasx() and it's y-counterparts - probalby they are only interesting, if all items stay on the canvas and not when deleting all items in each cycle.
* Check, if it is feasible to keep track of all elements created (drawn) on the canvas and update them instead of deleting all and creating them anew.
* Unify all function and variable names and also structure them more, e.g. pack them in classes if useful.
* scalable_canvas.py: Try to unify the two functions that scale coordinates (for creating drawing elements and for the sclaed motion event) - attention: the order of multiplication and addition is changed and the mathematical inverse operator is used except for the invert_y.
* scalable_canvas.py: Instead of get_* and set_* use real getters and setters or remove the existing ones, if they are not really needed - also adapt function to return tuples for x and y instead of separate functions.
* Put more comments in the code.
* On the ScalableCanvas <Configure> event the objects can even move out of the window then changing the window size - this seems onyl to happen when the object got moved away from the origin before.
* How to handle the scale factors (10000., etc.) in vehicle_visu, especially when changing the velocity and acceleration or when adding further vehicles with different parameters.
* Move all the timing variables hard defined in Gui.__init__() to the main program - find good calculations or define them for each vehicle visualization separately - probably also the trace_length_max parameter.
* Use a class/object to transport settings where there are so many, e.g. in VehicleVisu.draw(). Put this class inside the VehicleVisu class and can it be accessed from outside?
* Check if it makes sense to create a parent class for VehicleVisu and Sensor_Visu, since they share some operations, but not many.
* In the main loop trigger the measurement of the radar if measurement_interval passed.
* Test, if by choosing the element nearest to the mouse pointer on the canvas and keeping track of the association of the line segment, etc. to the vehicle/sensor, it is possible to select e.g. a sensor and interaxt with it (e.g. show a list of the recent measurements)
* The sensor needs access to the list of vehicles or pass each vehicle in the measure method?
* Put vv.add_cur_pos_to_trace() & Co. just inside the VehiclVisu class - at least provide a function, that calls all of that functions?
* Check, if complex numbers or a self defined type or tuples might make things easier with the (x, y) pairs.
* Possibly use a polygon instead of a rectangle to allow a rotation - but this does not help with ellipses e.g. - check, if it possible to manipulate in the depths of tkinter to rotate objects. See http://effbot.org/zone/tkinter-complex-canvas.htm.
* To correctly drawn the ellipse for a sensor's covariance matrix, the rotation and size needs to be determined from the covariance matrix before.
* Probably create a separate class than build the connection between the sensor and the vehicle, that gets measured. The problem occurs when visualizing the measurements, since the sensor does not know, which vehicle a specific measurement was from.
  -> Or just adapt the imperfect logic already implemented at SenvorVisu.draw() - handled_vehicles...
* Add checkbox for drawing measurements
* Add slider for number of cov ellipses (0..n), where 0 is deactivated